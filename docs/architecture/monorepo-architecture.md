# uDance Monorepo Architecture â€” v2

> **Status:** Draft â—¦ regenerated 2025-07-08 âœ”ï¸Ž next-15-ready

---

## 0. TL;DR (30 sec)

â€¢ 1 repo â†’ 3 Next.js apps â†’ 5 shared packages  
â€¢ Trust **Server Components + Actions** for all data writes.  
â€¢ Put every domain rule in `packages/domain/*`.  
â€¢ Global state? Use **Zustand** slices colocated with the feature.  
â€¢ No class components, no Context spaghetti.

---

## 1. Why a Monorepo for a Solo Dev?

1. **Zero copy-paste** â€“ one source of truth for DB types & helpers.  
2. **Turbo cache** gives incremental builds/tests (<2 s on M-series).  
3. **Future-proof** â€“ easy to onboard a contributor later.

If the overhead feels heavy, delete an unused package â€“ nothing breaks. ðŸ˜‰

---

## 2. Minimal Folder Blueprint

```text
udance/
â”œâ”€ apps/
â”‚  â”œâ”€ admin/   # heavy CRUD, studio dashboard
â”‚  â”œâ”€ pwa/     # mobile webapp (installs to home-screen)
â”‚  â””â”€ web/     # marketing + login + public explore
â”‚
â”œâ”€ packages/
â”‚  â”œâ”€ domain/  # **Models & services** (Supabase queries, zod schemas)
â”‚  â”œâ”€ ui/      # shared React components (server- & client-safe)
â”‚  â”œâ”€ store/   # Zustand slices (see Â§5)
â”‚  â”œâ”€ styles/  # Tailwind presets & tokens
â”‚  â””â”€ db/      # SQL migrations (auto-synced âžœ /supabase)
â”‚
â”œâ”€ supabase/   # local dev DB, generated by CLI
â””â”€ tools/      # lint, prettier, tsconfig bases
```

### Graph view

```mermaid
graph TD;
  subgraph Apps
    admin[admin] --imports--> ui;
    admin --calls--> domain;
    pwa[pwa] --- ui;
    pwa --- domain;
    web[web] --- ui;
    web --- domain;
  end
  domain -- depends on --> db[(db types)]
  store[store] -. consumer .-> ui
```

*Solid arrows* = ESM import.  *Dotted* = runtime usage only.

---

## 3. Next.js 15 Conventions

| âœ… Do | ðŸš« Don't |
| --- | --- |
| Keep everything in the **/app** router; forget `/pages`. | Mix routers. |
| Use **`export async function action()`** files for mutations. | Legacy API Routes unless truly public. |
| Default to **Server Components**; add `"use client"` only when the UI needs interactivity. | Blanket "use client" at top of every file. |
| Wrap Supabase client via the server context (cookies/session). | Instantiate Supabase per request in client code. |
| `revalidate = 0` for real-time pages, else pick sensible minutes. | Disable cache everywhere. |

### Example server action (admin app)
```ts
// apps/admin/src/app/(teachers)/actions.ts
import { upsertTeacher } from "@/domain/teachers";

export async function saveTeacher(form: FormData) {
  'use server';
  await upsertTeacher({
    name: form.get('name') as string,
    email: form.get('email') as string,
  });
}
```

---

## 4. Domain Layer (packages/domain)

*Pure TS, no React, no Next.js import.*  Each feature gets:

```
/teachers/
  â”œâ”€ schema.ts      # zod definitions
  â”œâ”€ queries.ts     # select helpers
  â”œâ”€ commands.ts    # insert / update helpers
  â””â”€ index.ts       # barrel export
```

This keeps all business invariants in one spot â€“ the **M** in MVC.

---

## 5. State Management with Zustand

1. One **slice = one concern** (auth, ui-prefs, cart â€¦).  
2. Slice lives near the *feature* (`packages/store/auth.ts`).  
3. SSR-safe hydration via `useStore(selector, shallow)`.

```ts
// packages/store/auth.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface AuthSlice { user?: User; login(u:User): void; logout(): void; }

export const useAuth = create<AuthSlice>()(persist((set) => ({
  user: undefined,
  login: (user) => set({ user }),
  logout: () => set({ user: undefined }),
}), { name: 'auth' }));
```

> In Server Components **never** call the store â€“ pass data as props instead.

---

## 6. End-to-End Flow: "Save Teacher"

```mermaid
sequenceDiagram
  participant UI as Client Component (Button)
  participant SA as Server Action (admin/actions.ts)
  participant Model as domain.teachers.commands
  participant DB as Postgres
  UI->>SA: formData
  SA->>Model: upsertTeacher(dto)
  Model->>DB: SQL upsert
  DB-->>Model: row
  Model-->>SA: result
  SA-->>UI: revalidatePath('/teachers')
```

*Only* the shaded SA + Model layers know Supabase; the UI stays blissfully unaware.

---

## 7. CI / DX Shortcuts

```jsonc
// turbo.json (excerpt)
{
  "pipeline": {
    "lint": { "outputs": [] },
    "test": { "dependsOn": ["^build"], "outputs": ["coverage/**"] },
    "build": { "dependsOn": ["^build"], "outputs": ["dist/**", ".next/**"] }
  }
}
```
*Run only what changed* âžœ `turbo run dev --filter=apps/web`.

---

## 8. Pitfalls & TODO

| Issue | Quick Win |
| --- | --- |
| Duplicate Supabase helpers (`utils/` vs `domain/`) | Delete `utils/supabase`, re-export from domain. |
| Legacy mockup HTML inflates repo size | Move to `/docs/wireframes` or delete. |
| Sporadic hydration mismatch with Zustand | Use `suppressHydrationWarning` on root provider or move state server-side. |

---

## 9. Next Steps

- [ ] Collapse scattered `actions.ts` into feature folders.  
- [ ] Add Playwright e2e hitting Server Actions.  
- [ ] Document RLS policy matrix.

---

*End of spec. Feel free to iterate & eventually promote to `memory-bank/archive/` once stable.* 

---

## 10. Local Dev Setup & One-liners

| Task | Command | Notes |
| --- | --- | --- |
| Install deps | `pnpm i` | Root-level; Turbo workspaces auto-link. |
| Start Supabase (local) | `supabase start` | Requires Docker. Creates `localhost:54322`. |
| Seed DB | `pnpm db:seed` | Runs `packages/db/seed-data.sql` via CLI. |
| Dev all apps | `turbo run dev` | Each app on its own port (see `package.json`). |
| Dev single app | `turbo run dev --filter=apps/web` | Hot reload + Turbo cache. |
| Lint + typecheck | `turbo run lint typecheck` | Fast thanks to remote cache. |
| Test watch | `turbo run test --parallel` | Vitest + jsdom for UI, Node for domain. |

> Tip: Add `alias tdev="turbo run dev --parallel"` to your shell.

---

## 11. Environment Variables Matrix

| Name | Scope | Example | Purpose |
| --- | --- | --- | --- |
| `NEXT_PUBLIC_SUPABASE_URL` | apps/* (client) | `https://xyz.supabase.co` | browser fetches |
| `NEXT_PUBLIC_SUPABASE_ANON_KEY` | apps/* (client) | `eyJhbGciOi...` | public auth |
| `SUPABASE_SERVICE_ROLE_KEY` | domain layer (server) | `secrettt` | privileged server actions |
| `DATABASE_URL` | packages/db, migrations | `postgres://postgres:pass@localhost:54322/postgres` | local PG connection |
| `VERCEL_ENV` | Vercel runtime | `preview` / `production` | feature flags |

All env vars live in `.env.example`; **never** commit secrets.

---

## 12. Migrations & Branching Workflow

```mermaid
graph LR
  A[Write migration.sql in packages/db/migrations] --> B(commit+PR)
  B -->|CI calls supabase db reset| C(Local Dev DB)
  C --> D[Merge to main]
  D -->|Turbo pipeline| E(Vercel Preview Build)
  D --> F(Supabase dev branch auto-applied)
  F -->|QA OK?| G(Supabase prod merge)
```

1. Create migration via `pnpm db:new create_teachers_table`.  
2. PR triggers GitHub Action â†’ spins Supabase branch, runs migration + unit tests.  
3. Merge to `main` auto-deploys apps + applies migration on **dev** DB.  
4. Promote to **prod** via Supabase dashboard once smoke tests pass.

Rollback = `supabase migrations down 1` in the branch, new PR.

---

## 13. Deployment Flow (Vercel)

| Step | Admin | PWA | Web |
| --- | --- | --- | --- |
| Preview | `admin-gitsha.vercel.app` | `pwa-gitsha.vercel.app` | `web-gitsha.vercel.app` |
| Prod URL | `admin.udance.com` | `pwa.udance.com` | `udance.com` |
| Edge Runtime | Yes | Yes | Yes |
| Image Optimizer | Remote patterns configured | â€“ | âœ… |

All three share the **same** Vercel project but different "app" sub-folders; handled by the new monorepo build feature.

---

## 14. Testing Strategy (Pyramid)

```mermaid
graph TD
  unit[Unit â€“ domain & utils] --> integration
  integration[Integration â€“ server actions w/ Supabase test DB] --> e2e
  e2e[End-to-End â€“ Playwright hitting deployed preview]
```

| Layer | Tooling | Location | Trigger |
| --- | --- | --- | --- |
| Unit | Vitest, ts-jest | `packages/**/__tests__` | `turbo run test` |
| Integration | Vitest + `supabase-js` | `apps/*/src/__tests__/` | CI only |
| E2E | Playwright | `/tests/e2e/**` | nightly + pre-prod |

Code coverage must stay â‰¥ 85 % on domain layer; enforced in pipeline.

---

## 15. CI Pipeline Diagram

```mermaid
flowchart LR
  checkout --> install
  install --> lint
  lint --> build
  build --> test
  test --> deploy{Branch}
  deploy -->|preview| vercelPreview
  deploy -->|main| vercelProd
  deploy -->|tag| npmPublish
```

*Hosted on GitHub Actions*. `lint` step uses `eslint --max-warnings 0`.  `build` caches with Turbo Remote Cache.  `npmPublish` only when a semver tag is pushed for a shared package.

---

## 16. Performance & UX Guidelines

1. **Edge First** â€“ enable Next.js `export const runtime = 'edge';` in data-light actions.  
2. Use `dynamic()` for heavy charts; fallback skeleton <200 ms LCP.  
3. Activate **Speculation Rules** for cross-app navigations (micro-frontends).  
4. Images: `next/image` + AVIF first.  
5. Fonts: `next/font/google` with `display:swap`.

---

## 17. Glossary

| Term | Meaning |
| --- | --- |
| **Domain Package** | Folder under `packages/domain` that owns a bounded context (teachers, events, payments). |
| **Server Action** | New Next 15 feature replacing API routes for mutations; runs exclusively on the server. |
| **Slice** | Zustand store part co-located with a feature. |
| **RLS** | Row Level Security rules in Supabase Postgres. |

---

## 18. Drizzle ORM + Zod â†’ Type-Safe DB Layer

We pair **Drizzle ORM** with Supabase for a fully-typed experience:

1. **Schema in TS** â€“ `packages/domain/**/schema.ts` declares tables via Drizzle's `pgTable`, mirroring SQL but living in code.  
2. **Zod validation** â€“ use `drizzle-zod` helper or hand-rolled schemas to validate inputs *before* hitting the DB.
3. **Migrations** â€“ `pnpm db:generate` â‡’ `drizzle-kit generate` creates SQL in `packages/db/migrations/*`.  Commit these; CI will run `drizzle-kit migrate` against the Supabase branch.
4. **Supabase connection** â€“ inside Server Actions/services:

```ts
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const client = postgres(process.env.SUPABASE_DATABASE_URL!, { prepare: false });
export const db = drizzle(client);
```

### Example slice
```ts
// packages/domain/news/schema.ts
import { pgTable, uuid, text, timestamp } from 'drizzle-orm/pg-core';
export const news = pgTable('news', {
  id: uuid('id').defaultRandom().primaryKey(),
  title: text('title').notNull(),
  content: text('content').notNull(),
  status: text('status', { enum: ['draft','published'] }).default('draft'),
  createdAt: timestamp('created_at').defaultNow(),
});
```
```ts
// packages/domain/news/zod.ts
import { z } from 'zod';
export const NewsInput = z.object({
  title: z.string().min(3),
  content: z.string().min(10),
  status: z.enum(['draft','published']).optional(),
});
```
```ts
// packages/domain/news/commands.ts
import { db } from '../db';
import { news } from './schema';
import { NewsInput } from './zod';

export async function createNews(payload: unknown) {
  const data = NewsInput.parse(payload);
  return db.insert(news).values(data).returning().get();
}
```

> Drizzle keeps bundle size small (~7 KB) and works great in **Server Actions**; Prisma's binary is heavier and slower for edge/serverless.

Update TL;DR:
â€¢ 1 repo â†’ 3 apps â†’ 5 pkgs, **Drizzle ORM + Supabase** for DB, Zod for validation.

---

*Need something not covered? ðŸ‘‰ Open an issue in `memory-bank/tasks.md`.* 